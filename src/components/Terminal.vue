<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch, nextTick } from 'vue'
import { Terminal as XTerm } from '@xterm/xterm'
import { FitAddon } from '@xterm/addon-fit'
import { SearchAddon } from '@xterm/addon-search'
import { WebLinksAddon } from '@xterm/addon-web-links'
import { useConfigStore } from '../stores/config'
import { useTerminalStore } from '../stores/terminal'
import { getTheme } from '../themes'
import { TerminalScreenService, type ScreenContent } from '../services/terminal-screen.service'
import { TerminalSnapshotManager, type TerminalSnapshot, type TerminalDiff } from '../services/terminal-snapshot.service'
import '@xterm/xterm/css/xterm.css'

const props = defineProps<{
  tabId: string
  ptyId: string
  type: 'local' | 'ssh'
  isActive: boolean
}>()

const configStore = useConfigStore()
const terminalStore = useTerminalStore()

const terminalRef = ref<HTMLDivElement | null>(null)
let terminal: XTerm | null = null
let fitAddon: FitAddon | null = null
let searchAddon: SearchAddon | null = null
let screenService: TerminalScreenService | null = null
let snapshotManager: TerminalSnapshotManager | null = null
let unsubscribe: (() => void) | null = null
let unsubscribeDisconnect: (() => void) | null = null  // SSH æ–­å¼€è¿æ¥äº‹ä»¶å–æ¶ˆè®¢é˜…
let unsubscribeScreenRequest: (() => void) | null = null  // ä¸»è¿›ç¨‹å±å¹•å†…å®¹è¯·æ±‚ç›‘å¬
let unsubscribeVisibleRequest: (() => void) | null = null  // ä¸»è¿›ç¨‹å¯è§†å†…å®¹è¯·æ±‚ç›‘å¬
let unsubscribeAnalysisRequest: (() => void) | null = null  // ä¸»è¿›ç¨‹å±å¹•åˆ†æè¯·æ±‚ç›‘å¬
let resizeObserver: ResizeObserver | null = null
let isDisposed = false
let isPasting = false
let keyDownHandler: ((event: KeyboardEvent) => void) | null = null
let resizeTimeout: ReturnType<typeof setTimeout> | null = null
let dprMediaQuery: MediaQueryList | null = null
let dprChangeHandler: (() => void) | null = null
// ç”¨æˆ·è¾“å…¥ç¼“å†²åŒºï¼ˆç”¨äº CWD è¿½è¸ªï¼‰
let inputBuffer = ''
// å±å¹•åˆ†æé˜²æŠ–å®šæ—¶å™¨
let screenAnalysisTimeout: ReturnType<typeof setTimeout> | null = null
const SCREEN_ANALYSIS_DEBOUNCE = 100 // 100ms é˜²æŠ–

// æ¨é€å±å¹•åˆ†æç»“æœåˆ°åç«¯
const pushScreenAnalysis = () => {
  if (screenAnalysisTimeout) {
    clearTimeout(screenAnalysisTimeout)
  }
  screenAnalysisTimeout = setTimeout(() => {
    if (screenService && !isDisposed) {
      try {
        const awarenessState = screenService.getAwarenessState()
        // åŒæ—¶æ¨é€å¯è§†åŒºåŸŸå†…å®¹ï¼Œä¾› Agent ä½¿ç”¨
        const visibleContent = screenService.getVisibleContent()
        window.electronAPI.terminalAwareness.updateScreenAnalysis(props.ptyId, {
          ...awarenessState,
          visibleContent
        })
      } catch (e) {
        // å¿½ç•¥åˆ†æé”™è¯¯
      }
    }
  }, SCREEN_ANALYSIS_DEBOUNCE)
}

// å³é”®èœå•çŠ¶æ€
const contextMenu = ref({
  visible: false,
  x: 0,
  y: 0,
  hasSelection: false,
  selectedText: ''
})

// åˆå§‹åŒ–ç»ˆç«¯
onMounted(async () => {
  if (!terminalRef.value) return

  // è·å–ä¸»é¢˜
  const theme = getTheme(configStore.currentTheme)
  const settings = configStore.terminalSettings

  // åˆ›å»ºç»ˆç«¯å®ä¾‹
  terminal = new XTerm({
    theme,
    fontSize: settings.fontSize,
    fontFamily: settings.fontFamily,
    cursorBlink: settings.cursorBlink,
    cursorStyle: settings.cursorStyle,
    scrollback: settings.scrollback,
    allowProposedApi: true,
    convertEol: true
  })

  // åŠ è½½æ’ä»¶
  fitAddon = new FitAddon()
  searchAddon = new SearchAddon()
  const webLinksAddon = new WebLinksAddon()

  terminal.loadAddon(fitAddon)
  terminal.loadAddon(searchAddon)
  terminal.loadAddon(webLinksAddon)

  // æŒ‚è½½åˆ° DOM
  terminal.open(terminalRef.value)

  // åˆ›å»ºå±å¹•æœåŠ¡å®ä¾‹
  screenService = new TerminalScreenService(terminal)
  
  // åˆ›å»ºå¿«ç…§ç®¡ç†å™¨
  snapshotManager = new TerminalSnapshotManager(screenService)
  
  // æ³¨å†Œå±å¹•æœåŠ¡å’Œå¿«ç…§ç®¡ç†å™¨åˆ° storeï¼ˆä¾›å¤–éƒ¨è®¿é—®ï¼‰
  terminalStore.registerScreenService(props.tabId, screenService)
  terminalStore.registerSnapshotManager(props.tabId, snapshotManager)

  // åˆå§‹åŒ–ç»ˆç«¯çŠ¶æ€æœåŠ¡ï¼ˆCWD è¿½è¸ªç­‰ï¼‰
  window.electronAPI.terminalState.init(props.ptyId, props.type)

  // é€‚é…å¤§å° - ä½¿ç”¨ setTimeout ç¡®ä¿ DOM å®Œå…¨æ¸²æŸ“å’Œå¸ƒå±€å®Œæˆ
  await nextTick()
  setTimeout(async () => {
    if (fitAddon && terminal && terminalRef.value) {
      // æ£€æŸ¥å®¹å™¨æ˜¯å¦æœ‰æœ‰æ•ˆå°ºå¯¸
      const rect = terminalRef.value.getBoundingClientRect()
      if (rect.width > 0 && rect.height > 0) {
        fitAddon.fit()
        // æ›´æ–°åç«¯ PTY å¤§å°
        const { cols, rows } = terminal
        await terminalStore.resizeTerminal(props.tabId, cols, rows)
        terminal.focus()
      }
    }
  }, 100)

  // ç›‘å¬ç”¨æˆ·è¾“å…¥
  if (!terminal) return
  terminal.onData(data => {
    terminalStore.writeToTerminal(props.tabId, data)
    
    // è¿½è¸ªç”¨æˆ·è¾“å…¥ï¼ˆç”¨äº CWD å˜åŒ–æ£€æµ‹ï¼‰
    // å½“ç”¨æˆ·æŒ‰ä¸‹å›è½¦æ—¶ï¼Œå‘é€å®Œæ•´å‘½ä»¤ç»™ç»ˆç«¯çŠ¶æ€æœåŠ¡
    if (data === '\r' || data === '\n') {
      if (inputBuffer.trim()) {
        window.electronAPI.terminalState.handleInput(props.ptyId, inputBuffer)
      }
      inputBuffer = ''
    } else if (data === '\x7f' || data === '\b') {
      // é€€æ ¼é”®ï¼Œåˆ é™¤ç¼“å†²åŒºæœ€åä¸€ä¸ªå­—ç¬¦
      inputBuffer = inputBuffer.slice(0, -1)
    } else if (data.length === 1 && data.charCodeAt(0) >= 32) {
      // æ™®é€šå¯æ‰“å°å­—ç¬¦
      inputBuffer += data
    } else if (data.length > 1 && !data.includes('\x1b')) {
      // ç²˜è´´çš„æ–‡æœ¬ï¼ˆä¸åŒ…å«è½¬ä¹‰åºåˆ—ï¼‰
      inputBuffer += data
    }
  })

  // å¤„ç† Ctrl+C å¤åˆ¶
  terminal.attachCustomKeyEventHandler((event: KeyboardEvent) => {
    // Ctrl+C å¤åˆ¶é€‰ä¸­å†…å®¹
    if ((event.ctrlKey || event.metaKey) && event.key === 'c' && event.type === 'keydown') {
      const selection = terminal?.getSelection()
      if (selection) {
        navigator.clipboard.writeText(selection)
        return false // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼ˆä¸å‘é€ SIGINTï¼‰
      }
      // æ²¡æœ‰é€‰ä¸­å†…å®¹æ—¶ï¼Œè®© Ctrl+C å‘é€åˆ°ç»ˆç«¯ï¼ˆä½œä¸ºä¸­æ–­ä¿¡å·ï¼‰
      return true
    }
    return true
  })

  // å¤„ç† Ctrl+V ç²˜è´´ - ç›‘å¬ DOM äº‹ä»¶
  const handlePaste = async () => {
    if (isPasting || isDisposed || !terminal) return
    isPasting = true
    
    try {
      const text = await navigator.clipboard.readText()
      if (text) {
        terminalStore.writeToTerminal(props.tabId, text)
      }
    } catch (e) {
      // å¿½ç•¥é”™è¯¯
    } finally {
      setTimeout(() => { isPasting = false }, 200)
    }
  }

  keyDownHandler = (event: KeyboardEvent) => {
    if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
      event.preventDefault()
      event.stopPropagation()
      handlePaste()
    }
  }

  if (terminalRef.value) {
    terminalRef.value.addEventListener('keydown', keyDownHandler, true)
  }

  // è®¢é˜…åç«¯æ•°æ®
  if (props.type === 'local') {
    unsubscribe = window.electronAPI.pty.onData(props.ptyId, (data: string) => {
      if (!isDisposed && terminal) {
        try {
          terminal.write(data)
          // æ•è·è¾“å‡ºç”¨äº AI åˆ†æ
          terminalStore.appendOutput(props.tabId, data)
          // æ¨é€å±å¹•åˆ†æç»“æœåˆ°åç«¯ï¼ˆç”¨äºç»ˆç«¯çŠ¶æ€æ„ŸçŸ¥ï¼‰
          pushScreenAnalysis()
        } catch (e) {
          // å¿½ç•¥å†™å…¥é”™è¯¯
        }
      }
    })
  } else {
    unsubscribe = window.electronAPI.ssh.onData(props.ptyId, (data: string) => {
      if (!isDisposed && terminal) {
        try {
          terminal.write(data)
          // æ•è·è¾“å‡ºç”¨äº AI åˆ†æ
          terminalStore.appendOutput(props.tabId, data)
          // æ¨é€å±å¹•åˆ†æç»“æœåˆ°åç«¯ï¼ˆç”¨äºç»ˆç«¯çŠ¶æ€æ„ŸçŸ¥ï¼‰
          pushScreenAnalysis()
        } catch (e) {
          // å¿½ç•¥å†™å…¥é”™è¯¯
        }
      }
    })

    // ç›‘å¬ SSH æ–­å¼€è¿æ¥äº‹ä»¶
    unsubscribeDisconnect = window.electronAPI.ssh.onDisconnected(props.ptyId, (event) => {
      if (!isDisposed && terminal) {
        // æ›´æ–°è¿æ¥çŠ¶æ€
        terminalStore.updateConnectionStatus(props.tabId, false)
        // åœ¨ç»ˆç«¯æ˜¾ç¤ºæ–­å¼€è¿æ¥æ¶ˆæ¯
        const reasonMap: Record<string, string> = {
          'closed': 'è¿æ¥å·²å…³é—­',
          'error': 'è¿æ¥é”™è¯¯',
          'stream_closed': 'æ•°æ®æµå·²å…³é—­',
          'jump_host_closed': 'è·³æ¿æœºè¿æ¥å·²æ–­å¼€'
        }
        const reasonText = reasonMap[event.reason] || event.reason
        const errorText = event.error ? `: ${event.error}` : ''
        terminal.write(`\r\n\x1b[31m[SSH è¿æ¥æ–­å¼€] ${reasonText}${errorText}\x1b[0m\r\n`)
      }
    })
  }

  // ç›‘å¬é€‰ä¸­æ–‡æœ¬å˜åŒ–
  terminal.onSelectionChange(() => {
    if (terminal) {
      const selection = terminal.getSelection()
      terminalStore.updateSelectedText(props.tabId, selection || '')
    }
  })

  // é‡æ–°é€‚é…ç»ˆç«¯å¤§å°çš„å‡½æ•°
  const doFit = () => {
    if (resizeTimeout) {
      clearTimeout(resizeTimeout)
    }
    resizeTimeout = setTimeout(() => {
      if (fitAddon && props.isActive && terminal && !isDisposed) {
        fitAddon.fit()
        terminalStore.resizeTerminal(props.tabId, terminal.cols, terminal.rows)
      }
    }, 50)
  }

  // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼ˆå¸¦é˜²æŠ–ï¼Œç¡®ä¿æœ€å¤§åŒ–ç­‰åŠ¨ç”»å®Œæˆåå†è®¡ç®—ï¼‰
  resizeObserver = new ResizeObserver(() => {
    doFit()
  })
  resizeObserver.observe(terminalRef.value)

  // ç›‘å¬ devicePixelRatio å˜åŒ–ï¼ˆçª—å£åœ¨ä¸åŒ DPI æ˜¾ç¤ºå™¨é—´ç§»åŠ¨æ—¶ï¼‰
  const updateDprListener = () => {
    if (dprMediaQuery && dprChangeHandler) {
      dprMediaQuery.removeEventListener('change', dprChangeHandler)
    }
    dprMediaQuery = window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`)
    dprMediaQuery.addEventListener('change', dprChangeHandler!)
  }

  dprChangeHandler = () => {
    // DPI å˜åŒ–æ—¶é‡æ–°é€‚é…ç»ˆç«¯
    doFit()
    // æ›´æ–°ç›‘å¬å™¨ä»¥è·Ÿè¸ªæ–°çš„ DPI å€¼
    updateDprListener()
  }

  updateDprListener()

  // æ³¨å†Œä¸»è¿›ç¨‹å±å¹•å†…å®¹è¯·æ±‚ç›‘å¬å™¨
  // å½“ä¸»è¿›ç¨‹éœ€è¦è·å–å‡†ç¡®çš„ç»ˆç«¯è¾“å‡ºæ—¶ï¼Œä¼šå‘é€è¯·æ±‚åˆ°æ¸²æŸ“è¿›ç¨‹
  unsubscribeScreenRequest = window.electronAPI.screen.onRequestLastNLines((data) => {
    // æ£€æŸ¥æ˜¯å¦æ˜¯å‘ç»™å½“å‰ç»ˆç«¯çš„è¯·æ±‚
    if (data.ptyId === props.ptyId && screenService && !isDisposed) {
      try {
        const lines = screenService.getLastNLines(data.lines)
        window.electronAPI.screen.responseLastNLines(data.requestId, lines)
      } catch (e) {
        // å‡ºé”™æ—¶è¿”å› nullï¼Œè®©ä¸»è¿›ç¨‹å›é€€åˆ°å…¶ä»–æ–¹å¼
        window.electronAPI.screen.responseLastNLines(data.requestId, null)
      }
    }
  })

  unsubscribeVisibleRequest = window.electronAPI.screen.onRequestVisibleContent((data) => {
    if (data.ptyId === props.ptyId && screenService && !isDisposed) {
      try {
        const lines = screenService.getVisibleContent()
        window.electronAPI.screen.responseVisibleContent(data.requestId, lines)
      } catch (e) {
        window.electronAPI.screen.responseVisibleContent(data.requestId, null)
      }
    }
  })

  // æ³¨å†Œå±å¹•åˆ†æè¯·æ±‚ç›‘å¬å™¨
  // å½“ä¸»è¿›ç¨‹ï¼ˆAgentï¼‰éœ€è¦å®æ—¶è·å–ç»ˆç«¯çŠ¶æ€åˆ†ææ—¶è°ƒç”¨
  unsubscribeAnalysisRequest = window.electronAPI.screen.onRequestScreenAnalysis((data) => {
    if (data.ptyId === props.ptyId && screenService && !isDisposed) {
      try {
        // è·å–å®Œæ•´çš„ç»ˆç«¯æ„ŸçŸ¥çŠ¶æ€ï¼ˆåŒ…å«è¾“å…¥ç­‰å¾…æ£€æµ‹ã€è¾“å‡ºæ¨¡å¼è¯†åˆ«ã€ç¯å¢ƒåˆ†æï¼‰
        const awarenessState = screenService.getAwarenessState()
        // åŒæ—¶è·å–å¯è§†åŒºåŸŸå†…å®¹
        const visibleContent = screenService.getVisibleContent()
        window.electronAPI.screen.responseScreenAnalysis(data.requestId, {
          ...awarenessState,
          visibleContent
        })
      } catch (e) {
        window.electronAPI.screen.responseScreenAnalysis(data.requestId, null)
      }
    }
  })
})

// æ¸…ç†
onUnmounted(() => {
  // å…ˆæ ‡è®°ä¸ºå·²é”€æ¯ï¼Œé˜²æ­¢åç»­å›è°ƒæ‰§è¡Œ
  isDisposed = true
  
  if (screenAnalysisTimeout) {
    clearTimeout(screenAnalysisTimeout)
    screenAnalysisTimeout = null
  }
  if (resizeTimeout) {
    clearTimeout(resizeTimeout)
    resizeTimeout = null
  }
  if (dprMediaQuery && dprChangeHandler) {
    dprMediaQuery.removeEventListener('change', dprChangeHandler)
    dprMediaQuery = null
    dprChangeHandler = null
  }
  if (unsubscribe) {
    unsubscribe()
    unsubscribe = null
  }
  if (unsubscribeDisconnect) {
    unsubscribeDisconnect()
    unsubscribeDisconnect = null
  }
  if (unsubscribeScreenRequest) {
    unsubscribeScreenRequest()
    unsubscribeScreenRequest = null
  }
  if (unsubscribeVisibleRequest) {
    unsubscribeVisibleRequest()
    unsubscribeVisibleRequest = null
  }
  if (unsubscribeAnalysisRequest) {
    unsubscribeAnalysisRequest()
    unsubscribeAnalysisRequest = null
  }
  if (resizeObserver) {
    resizeObserver.disconnect()
    resizeObserver = null
  }
  if (keyDownHandler && terminalRef.value) {
    terminalRef.value.removeEventListener('keydown', keyDownHandler, true)
    keyDownHandler = null
  }
  // æ³¨é”€å±å¹•æœåŠ¡å’Œå¿«ç…§ç®¡ç†å™¨
  terminalStore.unregisterScreenService(props.tabId)
  terminalStore.unregisterSnapshotManager(props.tabId)
  screenService = null
  snapshotManager = null
  
  // ç§»é™¤ç»ˆç«¯çŠ¶æ€
  window.electronAPI.terminalState.remove(props.ptyId)
  inputBuffer = ''
  
  if (terminal) {
    terminal.dispose()
    terminal = null
  }
  fitAddon = null
  searchAddon = null
})

// å½“æ ‡ç­¾é¡µæ¿€æ´»æ—¶ï¼Œé‡æ–°é€‚é…å¤§å°å¹¶èšç„¦
watch(
  () => props.isActive,
  async active => {
    if (active && terminal && fitAddon && terminalRef.value) {
      await nextTick()
      setTimeout(() => {
        if (fitAddon && terminal && terminalRef.value) {
          const rect = terminalRef.value.getBoundingClientRect()
          if (rect.width > 0 && rect.height > 0) {
            fitAddon.fit()
            terminal.focus()
            terminalStore.resizeTerminal(props.tabId, terminal.cols, terminal.rows)
          }
        }
      }, 50)
    }
  },
  { immediate: true }
)

// ç›‘å¬ä¸»é¢˜å˜åŒ–
watch(
  () => configStore.currentTheme,
  themeName => {
    if (terminal) {
      const theme = getTheme(themeName)
      terminal.options.theme = theme
    }
  }
)

// ç›‘å¬ç„¦ç‚¹è¯·æ±‚ï¼ˆä» AI åŠ©æ‰‹å‘é€ä»£ç åˆ°ç»ˆç«¯åè‡ªåŠ¨èšç„¦ï¼‰
watch(
  () => terminalStore.pendingFocusTabId,
  (focusTabId) => {
    if (focusTabId === props.tabId && terminal) {
      nextTick(() => {
        terminal?.focus()
        terminalStore.clearPendingFocus()
      })
    }
  }
)

// å³é”®èœå•å¤„ç†
const handleContextMenu = (event: MouseEvent) => {
  event.preventDefault()
  
  const selection = terminal?.getSelection() || ''
  contextMenu.value = {
    visible: true,
    x: event.clientX,
    y: event.clientY,
    hasSelection: selection.length > 0,
    selectedText: selection
  }
}

const hideContextMenu = () => {
  contextMenu.value.visible = false
  // è®©ç»ˆç«¯é‡æ–°è·å¾—ç„¦ç‚¹
  nextTick(() => {
    terminal?.focus()
  })
}

const menuCopy = async () => {
  if (contextMenu.value.selectedText) {
    await navigator.clipboard.writeText(contextMenu.value.selectedText)
  }
  hideContextMenu()
}

const menuPaste = async () => {
  try {
    const text = await navigator.clipboard.readText()
    if (text) {
      terminalStore.writeToTerminal(props.tabId, text)
    }
  } catch (e) {
    // å¿½ç•¥é”™è¯¯
  }
  hideContextMenu()
}

const menuSendToAi = () => {
  if (contextMenu.value.selectedText) {
    terminalStore.sendToAi(contextMenu.value.selectedText)
  }
  hideContextMenu()
}

const menuClear = () => {
  terminal?.clear()
  hideContextMenu()
}


// æš´éœ²æ–¹æ³•ä¾›å¤–éƒ¨è°ƒç”¨
defineExpose({
  focus: () => terminal?.focus(),
  search: (text: string) => searchAddon?.findNext(text),
  clear: () => terminal?.clear(),
  // å±å¹•å†…å®¹è¯»å–æ–¹æ³•
  getScreenContent: (): ScreenContent | null => screenService?.getScreenContent() ?? null,
  getVisibleContent: (): string[] => screenService?.getVisibleContent() ?? [],
  getLastNLines: (n: number): string[] => screenService?.getLastNLines(n) ?? [],
  getCursorPosition: () => screenService?.getCursorPosition() ?? { x: 0, y: 0 },
  getCurrentLine: () => screenService?.getCurrentLine() ?? '',
  isAtPrompt: () => screenService?.isAtPrompt() ?? false,
  detectErrors: (maxLines?: number) => screenService?.detectErrors(maxLines) ?? [],
  // å¿«ç…§ç›¸å…³æ–¹æ³•
  createSnapshot: (name?: string): TerminalSnapshot | null => snapshotManager?.createSnapshot(name) ?? null,
  getSnapshot: (name: string): TerminalSnapshot | undefined => snapshotManager?.getSnapshot(name),
  snapshotAndCompare: (): { snapshot: TerminalSnapshot; diff: TerminalDiff | null } | null => 
    snapshotManager?.snapshotAndCompare() ?? null,
  hasContentChanged: (): boolean => snapshotManager?.hasContentChanged() ?? true,
  getNewOutputSinceLastSnapshot: (): string[] => snapshotManager?.getNewOutputSinceLastSnapshot() ?? []
})
</script>

<template>
  <div 
    class="terminal-wrapper" 
    @contextmenu="handleContextMenu"
    @click="hideContextMenu"
  >
    <div ref="terminalRef" class="terminal-inner"></div>
  </div>
  
  <!-- å³é”®èœå• -->
  <Teleport to="body">
    <div 
      v-if="contextMenu.visible" 
      class="context-menu"
      :style="{ left: contextMenu.x + 'px', top: contextMenu.y + 'px' }"
      @click.stop
    >
      <div 
        class="menu-item"
        :class="{ disabled: !contextMenu.hasSelection }"
        @click="contextMenu.hasSelection && menuSendToAi()"
      >
        <span class="menu-icon">ğŸ¤–</span>
        <span>å‘é€åˆ° AI åˆ†æ</span>
      </div>
      <div class="menu-divider"></div>
      <div 
        class="menu-item" 
        :class="{ disabled: !contextMenu.hasSelection }"
        @click="contextMenu.hasSelection && menuCopy()"
      >
        <span class="menu-icon">ğŸ“‹</span>
        <span>å¤åˆ¶</span>
        <span class="shortcut">Ctrl+C</span>
      </div>
      <div class="menu-item" @click="menuPaste()">
        <span class="menu-icon">ğŸ“„</span>
        <span>ç²˜è´´</span>
        <span class="shortcut">Ctrl+V</span>
      </div>
      <div class="menu-divider"></div>
      <div class="menu-item" @click="menuClear()">
        <span class="menu-icon">ğŸ—‘ï¸</span>
        <span>æ¸…å±</span>
      </div>
    </div>
    <div 
      v-if="contextMenu.visible" 
      class="context-menu-overlay" 
      @click="hideContextMenu"
    ></div>
  </Teleport>
</template>

<style scoped>
.terminal-wrapper {
  width: 100%;
  height: 100%;
  padding: 8px;
  box-sizing: border-box;
  overflow: hidden;
}

.terminal-inner {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.terminal-inner :deep(.xterm) {
  height: 100% !important;
}

.terminal-inner :deep(.xterm-viewport) {
  overflow-y: auto !important;
}

/* å³é”®èœå•é®ç½©å±‚ */
.context-menu-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 999;
}

/* å³é”®èœå• */
.context-menu {
  position: fixed;
  z-index: 1000;
  min-width: 180px;
  background: var(--bg-secondary, #2d2d30);
  border: 1px solid var(--border-color, #404040);
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  padding: 4px 0;
  font-size: 13px;
}

.menu-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  cursor: pointer;
  color: var(--text-primary, #e0e0e0);
  transition: background-color 0.15s;
}

.menu-item:hover:not(.disabled) {
  background: var(--bg-hover, #094771);
}

.menu-item.disabled {
  color: var(--text-disabled, #6e6e6e);
  cursor: not-allowed;
}

.menu-icon {
  width: 20px;
  margin-right: 8px;
  font-size: 14px;
}

.shortcut {
  margin-left: auto;
  color: var(--text-secondary, #888);
  font-size: 11px;
}

.menu-divider {
  height: 1px;
  background: var(--border-color, #404040);
  margin: 4px 0;
}
</style>

